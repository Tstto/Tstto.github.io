<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React全家桶（三）</title>
    <link href="/2021/11/01/React%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/11/01/React%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-React应用（基于React脚手架）"><a href="#第三章-React应用（基于React脚手架）" class="headerlink" title="第三章 React应用（基于React脚手架）"></a>第三章 React应用（基于React脚手架）</h1><h2 id="3-1-使用create-react-app创建react应用"><a href="#3-1-使用create-react-app创建react应用" class="headerlink" title="3.1. 使用create-react-app创建react应用"></a>3.1. 使用create-react-app创建react应用</h2><h5 id="3-1-1-react脚手架"><a href="#3-1-1-react脚手架" class="headerlink" title="3.1.1. react脚手架"></a>3.1.1. react脚手架</h5><ol><li>xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目</li></ol><ul><li>包含了所有需要的配置（语法检查、jsx编译、devServer…）</li><li>下载好了所有相关的依赖</li><li>可以直接运行一个简单效果</li></ul><ol start="2"><li>react提供了一个用于创建react项目的脚手架库: create-react-app</li><li>项目的整体技术架构为:  react + webpack + es6 + eslint</li><li>使用脚手架开发的项目的特点: 模块化, 组件化, 工程化（一条龙服务）</li></ol><h5 id="3-1-2-创建项目并启动"><a href="#3-1-2-创建项目并启动" class="headerlink" title="3.1.2.创建项目并启动"></a>3.1.2.创建项目并启动</h5><p><strong>第一步</strong>，全局安装：npm i -g create-react-app</p><p><strong>第二步</strong>，切换到想创项目的目录，使用命令：create-react-app react_staging</p><p><strong>第三步</strong>，进入项目文件夹：cd react_staging</p><p><strong>第四步</strong>，启动项目：npm start</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React全家桶（二）</title>
    <link href="/2021/10/29/React%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/10/29/React%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-React面向组件编程"><a href="#第二章-React面向组件编程" class="headerlink" title="第二章 React面向组件编程"></a>第二章 React面向组件编程</h1><h2 id="2-1基本理解与使用"><a href="#2-1基本理解与使用" class="headerlink" title="2.1基本理解与使用"></a>2.1基本理解与使用</h2><h5 id="2-1-1函数式组件"><a href="#2-1-1函数式组件" class="headerlink" title="2.1.1函数式组件"></a>2.1.1函数式组件</h5><p>没有this指针，不能进行state、refs属性操作，但可以进行props操作，因为函数可以接收参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">···<br><span class="hljs-comment">//1.创建函数式组件</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//此处的this是undefined，因为babel编译后开启了严格模式</span><br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用函数定义的组件(适用于【简单组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>&#125;<br><span class="hljs-comment">//2.渲染组件到页面</span><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>))<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？</span><br><span class="hljs-comment">1.React解析组件标签，找到了MyComponent组件。</span><br><span class="hljs-comment">2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="2-1-2类式组件"><a href="#2-1-2类式组件" class="headerlink" title="2.1.2类式组件"></a>2.1.2类式组件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">···<br><span class="hljs-comment">//1.创建类式组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//render是放在哪里的？—— MyComponent的原型对象上，供实例使用。</span><br><span class="hljs-comment">//render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;render中的this:&#x27;</span>,<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是用类定义的组件(适用于【复杂组件】的定义)<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>&#125;<br>&#125;<br><span class="hljs-comment">//2.渲染组件到页面</span><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>))<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">执行了ReactDOM.render(&lt;MyComponent/&gt;.......之后，发生了什么？</span><br><span class="hljs-comment">1.React解析组件标签，找到了MyComponent组件。</span><br><span class="hljs-comment">2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。</span><br><span class="hljs-comment">3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="2-2组件三大核心属性：state"><a href="#2-2组件三大核心属性：state" class="headerlink" title="2.2组件三大核心属性：state"></a>2.2组件三大核心属性：state</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;constructor&#x27;</span>);<br><span class="hljs-built_in">super</span>(props)<br><span class="hljs-comment">//初始化状态，写成对象形式</span><br><span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">isHot</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">wind</span>:<span class="hljs-string">&#x27;微风&#x27;</span>&#125;<br>    <span class="hljs-comment">//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span><br><span class="hljs-comment">//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined</span><br><span class="hljs-comment">//解决changeWeather中this指向问题</span><br><span class="hljs-built_in">this</span>.changeWeather = <span class="hljs-built_in">this</span>.changeWeather.bind(<span class="hljs-built_in">this</span>)<br>&#125;<br>···<br><span class="hljs-comment">//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。</span><br><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">isHot</span>:!isHot&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><p>优化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">state = &#123;<span class="hljs-attr">isHot</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">wind</span>:<span class="hljs-string">&#x27;微风&#x27;</span>&#125;<br>···<br><span class="hljs-comment">//自定义方法————要用赋值语句的形式+箭头函数</span><br>changeWeather = <span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> isHot = <span class="hljs-built_in">this</span>.state.isHot<br><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">isHot</span>:!isHot&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3组件三大核心属性：props"><a href="#2-3组件三大核心属性：props" class="headerlink" title="2.3组件三大核心属性：props"></a>2.3组件三大核心属性：props</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">···<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">const</span> &#123;name,age,sex&#125; = <span class="hljs-built_in">this</span>.props<br><span class="hljs-keyword">return</span> (<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//渲染组件到页面</span><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jerry&quot;</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&#123;19&#125;</span>  <span class="hljs-attr">sex</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test1&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//对标签属性进行类型、必要性的限制</span><br>Person.propTypes = &#123;<br><span class="hljs-attr">name</span>:PropTypes.string.isRequired, <span class="hljs-comment">//限制name必传，且为字符串</span><br><span class="hljs-attr">sex</span>:PropTypes.string,<span class="hljs-comment">//限制sex为字符串</span><br><span class="hljs-attr">age</span>:PropTypes.number,<span class="hljs-comment">//限制age为数值</span><br><span class="hljs-attr">speak</span>:PropTypes.func,<span class="hljs-comment">//限制speak为函数</span><br>&#125;<br><span class="hljs-comment">//指定默认标签属性值</span><br>Person.defaultProps = &#123;<br><span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-comment">//sex默认值为男</span><br><span class="hljs-attr">age</span>:<span class="hljs-number">18</span> <span class="hljs-comment">//age默认值为18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>props是只读的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br><span class="hljs-comment">//构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</span><br><span class="hljs-comment">// console.log(props);</span><br><span class="hljs-built_in">super</span>(props)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;constructor&#x27;</span>,<span class="hljs-built_in">this</span>.props);<br>&#125;<br></code></pre></td></tr></table></figure><p>函数式组件使用props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params">props</span>)</span>&#123;<br><span class="hljs-keyword">const</span> &#123;name,age,sex&#125; = props<br><span class="hljs-keyword">return</span> (<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4组件三大核心属性：refs"><a href="#2-4组件三大核心属性：refs" class="headerlink" title="2.4组件三大核心属性：refs"></a>2.4组件三大核心属性：refs</h2><h5 id="2-4-1字符串形式的ref"><a href="#2-4-1字符串形式的ref" class="headerlink" title="2.4.1字符串形式的ref"></a>2.4.1字符串形式的ref</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//展示左侧输入框的数据</span><br>showData = <span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> &#123;input1&#125; = <span class="hljs-built_in">this</span>.refs<br>alert(input1.value)<br>&#125;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;input1&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span><span class="hljs-symbol">&amp;nbsp;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>点我提示左侧的数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-2回调形式的ref"><a href="#2-4-2回调形式的ref" class="headerlink" title="2.4.2回调形式的ref"></a>2.4.2回调形式的ref</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//展示左侧输入框的数据</span><br>showData = <span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-keyword">const</span> &#123;input1&#125; = <span class="hljs-built_in">this</span><br>alert(input1.value)<br>&#125;<br>            ···<br>            &lt;input ref=&#123;<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-built_in">this</span>.input1 = c &#125; type=<span class="hljs-string">&quot;text&quot;</span> placeholder=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;&amp;nbsp;<br></code></pre></td></tr></table></figure><h5 id="2-4-3回调ref中回调执行次数的问题"><a href="#2-4-3回调ref中回调执行次数的问题" class="headerlink" title="2.4.3回调ref中回调执行次数的问题"></a>2.4.3回调ref中回调执行次数的问题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</span><br>saveInput = <span class="hljs-function">(<span class="hljs-params">c</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">this</span>.input1 = c;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;@&#x27;</span>,c);<br>&#125;<br>···<br>&lt;input ref=&#123;<span class="hljs-built_in">this</span>.saveInput&#125; type=<span class="hljs-string">&quot;text&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h5 id="2-4-4createRef的使用"><a href="#2-4-4createRef的使用" class="headerlink" title="2.4.4createRef的使用"></a>2.4.4createRef的使用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点,该容器是“专人专用”的*/</span><br>myRef = React.createRef()<br><span class="hljs-comment">//展示左侧输入框的数据</span><br>showData = <span class="hljs-function">()=&gt;</span>&#123;<br>alert(<span class="hljs-built_in">this</span>.myRef.current.value);<br>&#125;<br>            <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myRef&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;点击按钮提示数据&quot;</span>/&gt;</span><span class="hljs-symbol">&amp;nbsp;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.showData&#125;</span>&gt;</span>点我提示左侧的数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span></span><br><span class="xml">                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-5事件处理"><a href="#2-4-5事件处理" class="headerlink" title="2.4.5事件处理"></a>2.4.5事件处理</h5><p>(1).通过onXxx属性指定事件处理函数(注意大小写)</p><p> a.React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 — 为了更好的兼容性</p><p> b.React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) —为了高效</p><p>(2).通过event.target得到发生事件的DOM元素对象 —不要过度使用ref</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">showData = <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>&#123;<br>alert(event.target.value);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5收集表单数据"><a href="#2-5收集表单数据" class="headerlink" title="2.5收集表单数据"></a>2.5收集表单数据</h2><h5 id="2-5-1包含表单的组件分类"><a href="#2-5-1包含表单的组件分类" class="headerlink" title="2.5.1包含表单的组件分类"></a>2.5.1包含表单的组件分类</h5><p>​    a.非受控组件（现用现调）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br><span class="hljs-comment">//创建组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>handleSubmit = <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>&#123;<br>event.preventDefault() <span class="hljs-comment">//阻止表单提交</span><br><span class="hljs-keyword">const</span> &#123;username,password&#125; = <span class="hljs-built_in">this</span><br>alert(<span class="hljs-string">`你输入的用户名是：<span class="hljs-subst">$&#123;username.value&#125;</span>,你输入的密码是：<span class="hljs-subst">$&#123;password.value&#125;</span>`</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="xml">用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;c</span> =&gt;</span> this.username = c&#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;</span><br><span class="xml">密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;c</span> =&gt;</span> this.password = c&#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//渲染组件</span><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​    b.受控组件（类似于Vue中的V-Model双向数据绑定）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/babel&quot;</span>&gt;<br><span class="hljs-comment">//创建组件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Login</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br><br><span class="hljs-comment">//初始化状态</span><br>state = &#123;<br><span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">//用户名</span><br><span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">//密码</span><br>&#125;<br><br><span class="hljs-comment">//保存用户名到状态中</span><br>saveUsername = <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">username</span>:event.target.value&#125;)<br>&#125;<br><br><span class="hljs-comment">//保存密码到状态中</span><br>savePassword = <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">password</span>:event.target.value&#125;)<br>&#125;<br><br><span class="hljs-comment">//表单提交的回调</span><br>handleSubmit = <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>&#123;<br>event.preventDefault() <span class="hljs-comment">//阻止表单提交</span><br><span class="hljs-keyword">const</span> &#123;username,password&#125; = <span class="hljs-built_in">this</span>.state<br>alert(<span class="hljs-string">`你输入的用户名是：<span class="hljs-subst">$&#123;username&#125;</span>,你输入的密码是：<span class="hljs-subst">$&#123;password&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="xml">用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.saveUsername&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span></span><br><span class="xml">密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.savePassword&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//渲染组件</span><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Login</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h5 id="2-5-2高阶函数与函数的柯里化"><a href="#2-5-2高阶函数与函数的柯里化" class="headerlink" title="2.5.2高阶函数与函数的柯里化"></a>2.5.2高阶函数与函数的柯里化</h5><p>高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。</p><ol><li><p>若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。</p></li><li><p>若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。</p><p>常见的高阶函数有：Promise、setTimeout、arr.map()等等</p></li></ol><p>函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a</span>)</span>&#123;<br><span class="hljs-keyword">return</span><span class="hljs-function">(<span class="hljs-params">b</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">c</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> a+b+c<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//保存表单数据到状态中</span><br>saveFormData = <span class="hljs-function">(<span class="hljs-params">dataType</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">event</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">this</span>.setState(&#123;[dataType]:event.target.value&#125;)<br>&#125;<br>&#125;<br>···<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="xml">用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.saveFormData(</span>&#x27;<span class="hljs-attr">username</span>&#x27;)&#125; <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>/&gt;</span></span><br><span class="xml">密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.saveFormData(</span>&#x27;<span class="hljs-attr">password</span>&#x27;)&#125; <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>不用函数柯里化的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//保存表单数据到状态中</span><br>saveFormData = <span class="hljs-function">(<span class="hljs-params">dataType,event</span>)=&gt;</span>&#123;<br><span class="hljs-built_in">this</span>.setState(&#123;[dataType]:event.target.value&#125;)<br>&#125;<br>···<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="xml">用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;event</span> =&gt;</span> this.saveFormData(&#x27;username&#x27;,event) &#125; type=&quot;text&quot; name=&quot;username&quot;/&gt;</span><br><span class="xml">密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;event</span> =&gt;</span> this.saveFormData(&#x27;password&#x27;,event) &#125; type=&quot;password&quot; name=&quot;password&quot;/&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6组件的生命周期"><a href="#2-6组件的生命周期" class="headerlink" title="2.6组件的生命周期"></a>2.6组件的生命周期</h2><p>render调用n+1次，状态更新会重新渲染页面</p><h5 id="2-6-1引出生命周期"><a href="#2-6-1引出生命周期" class="headerlink" title="2.6.1引出生命周期"></a>2.6.1引出生命周期</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//创建组件</span><br><span class="hljs-comment">//生命周期回调函数 &lt;=&gt; 生命周期钩子函数 &lt;=&gt; 生命周期函数 &lt;=&gt; 生命周期钩子</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Life</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br><br>state = &#123;<span class="hljs-attr">opacity</span>:<span class="hljs-number">1</span>&#125;<br><br>death = <span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-comment">//卸载组件</span><br>ReactDOM.unmountComponentAtNode(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>))<br>&#125;<br><br><span class="hljs-comment">//组件挂载完毕</span><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;componentDidMount&#x27;</span>);<br><span class="hljs-built_in">this</span>.timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">//获取原状态</span><br><span class="hljs-keyword">let</span> &#123;opacity&#125; = <span class="hljs-built_in">this</span>.state<br><span class="hljs-comment">//减小0.1</span><br>opacity -= <span class="hljs-number">0.1</span><br><span class="hljs-keyword">if</span>(opacity &lt;= <span class="hljs-number">0</span>) opacity = <span class="hljs-number">1</span><br><span class="hljs-comment">//设置新的透明度</span><br><span class="hljs-built_in">this</span>.setState(&#123;opacity&#125;)<br>&#125;, <span class="hljs-number">200</span>);<br>&#125;<br><br><span class="hljs-comment">//组件将要卸载</span><br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//清除定时器</span><br><span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.timer)<br>&#125;<br><br><span class="hljs-comment">//初始化渲染、状态更新之后</span><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;render&#x27;</span>);<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">                    //外面的&#123;&#125;解析成js语法，里面的&#123;&#125;要求写成对象形式</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;opacity:this.state.opacity&#125;&#125;</span>&gt;</span>React学不会怎么办？<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.death&#125;</span>&gt;</span>不活了<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br>&#125;<br>&#125;<br><span class="hljs-comment">//渲染组件</span><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Life</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><h5 id="2-6-2react生命周期（旧）"><a href="#2-6-2react生命周期（旧）" class="headerlink" title="2.6.2react生命周期（旧）"></a>2.6.2react生命周期（旧）</h5><p><img src="/pic/React/1.png" alt="react生命周期(旧)"></p><ol><li>初始化阶段: 由ReactDOM.render()触发—初次渲染</li></ol><ul><li>constructor()</li><li>componentWillMount()</li><li>render()</li><li>componentDidMount() =====&gt; 常用 一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</li></ul><ol start="2"><li><p>更新阶段: 由组件内部this.setSate()或父组件render触发</p><p>  componentWillReceiveProps(props)    //组件将要接收新的props的钩子</p></li></ol><ul><li>shouldComponentUpdate()    //控制组件更新的“阀门”，有返回值return</li><li>componentWillUpdate()</li><li>render() =====&gt; 必须使用的一个</li><li> componentDidUpdate()</li></ul><ol start="3"><li>卸载组件: 由ReactDOM.unmountComponentAtNode()触发</li></ol><ul><li>componentWillUnmount()  =====&gt; 常用 一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</li></ul><h5 id="2-6-3react生命周期-新"><a href="#2-6-3react生命周期-新" class="headerlink" title="2.6.3react生命周期(新)"></a>2.6.3react生命周期(新)</h5><p><img src="/pic/React/2.png" alt="react生命周期(新)"></p><p>getSnapshotBeforeUpdate()使用场景：在更新之前获取快照</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br><br>state = &#123;<span class="hljs-attr">newsArr</span>:[]&#125;<br><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-comment">//获取原状态</span><br><span class="hljs-keyword">const</span> &#123;newsArr&#125; = <span class="hljs-built_in">this</span>.state<br><span class="hljs-comment">//模拟一条新闻</span><br><span class="hljs-keyword">const</span> news = <span class="hljs-string">&#x27;新闻&#x27;</span>+ (newsArr.length+<span class="hljs-number">1</span>)<br><span class="hljs-comment">//更新状态</span><br><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">newsArr</span>:[news,...newsArr]&#125;)<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.refs.list.scrollHeight<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">preProps,preState,height</span>)</span>&#123;<br><span class="hljs-built_in">this</span>.refs.list.scrollTop += <span class="hljs-built_in">this</span>.refs.list.scrollHeight - height<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span>(<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span></span><br><span class="xml">&#123;</span><br><span class="xml">this.state.newsArr.map((n,index)=&gt;&#123;</span><br><span class="xml">return <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;news&quot;</span>&gt;</span>&#123;n&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">&#125;)</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br>&#125;<br>&#125;<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NewsList</span>/&gt;</span></span>,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>))<br></code></pre></td></tr></table></figure><ol><li>初始化阶段: 由ReactDOM.render()触发—初次渲染</li></ol><ul><li>constructor()</li></ul><ul><li>getDerivedStateFromProps </li><li>render()</li><li>componentDidMount() =====&gt; 常用 一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息</li></ul><ol start="2"><li>更新阶段: 由组件内部this.setSate()或父组件重新render触发</li></ol><ul><li><p>getDerivedStateFromProps</p></li><li><p> shouldComponentUpdate()</p></li><li><p>render()</p></li></ul><ul><li>getSnapshotBeforeUpdate</li></ul><ul><li>componentDidUpdate()</li></ul><ol start="3"><li>卸载组件: 由ReactDOM.unmountComponentAtNode()触发</li></ol><ul><li>componentWillUnmount()  =====&gt; 常用 一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息</li></ul><h2 id="2-7DOM的Diffing算法"><a href="#2-7DOM的Diffing算法" class="headerlink" title="2.7DOM的Diffing算法"></a>2.7DOM的Diffing算法</h2><p>Diffing算法针对标签，可以逐层比较</p><ol><li><p>虚拟DOM中key的作用：</p><p>​    1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。</p><p>​    2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：</p><p>​         a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：</p><p>​            (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM</p><p>​            (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>​        b. 旧虚拟DOM中未找到与新虚拟DOM相同的key</p><p>​            根据数据创建新的真实DOM，随后渲染到到页面</p></li><li><p>用index作为key可能会引发的问题：</p><p>​    1）若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p><p>​    2）如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。</p><p>​    3）注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p></li></ol><ol start="3"><li><p>开发中如何选择key?:</p><p>​    1）最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</p><p>​    2）如果确定只是简单的展示数据，用index也是可以的。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React全家桶（一）</title>
    <link href="/2021/10/29/React%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/10/29/React%E5%85%A8%E5%AE%B6%E6%A1%B6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-React入门"><a href="#第一章-React入门" class="headerlink" title="第一章 React入门"></a>第一章 React入门</h1><h2 id="1-1-React简介"><a href="#1-1-React简介" class="headerlink" title="1.1 React简介"></a>1.1 React简介</h2><h5 id="1-1-1介绍描述"><a href="#1-1-1介绍描述" class="headerlink" title="1.1.1介绍描述"></a>1.1.1介绍描述</h5><p>用于动态构建用户界面的 JavaScript 库(只关注于视图)，也可以说是一个将数据动态渲染为HTML视图的开源JavaScript库</p><h5 id="1-1-2-React的特点"><a href="#1-1-2-React的特点" class="headerlink" title="1.1.2 React的特点"></a>1.1.2 React的特点</h5><ol><li>声明式编码（与命令式相对）</li><li>组件化编码（可拆分html、css、js）</li><li>React Native编写原生应用，可进行移动端开发<ol><li>使用<strong>虚拟DOM</strong>+优秀的<strong>Diffing算法</strong>，尽量减少与真实DOM的交互（不总是直接操作页面真实DOM，最小化页面重绘）</li></ol></li></ol><h2 id="1-2React的基本使用"><a href="#1-2React的基本使用" class="headerlink" title="1.2React的基本使用"></a>1.2React的基本使用</h2><h5 id="1-2-1相关js库"><a href="#1-2-1相关js库" class="headerlink" title="1.2.1相关js库"></a>1.2.1相关js库</h5><ol><li>react.development.js：React核心库</li><li>react-dom.development.js：提供操作DOM的react扩展库</li><li>babel.min.js：解析JSX语法代码转为JS代码的库（也有ES6转换为ES5）</li></ol><h5 id="1-2-2创建虚拟DOM的两种方式"><a href="#1-2-2创建虚拟DOM的两种方式" class="headerlink" title="1.2.2创建虚拟DOM的两种方式"></a>1.2.2创建虚拟DOM的两种方式</h5><ol><li>纯JS方式（利用React里面的API，React.createElement)</li><li>JSX方式（需要引入babel翻译）</li></ol><h2 id="1-3React-JSX"><a href="#1-3React-JSX" class="headerlink" title="1.3React JSX"></a>1.3React JSX</h2><p>全称：JavaScript XML</p><p>基本语法规则：</p><ol><li>定义虚拟DOM，不要写引号</li><li>标签中混入JS表达式时要用{ }</li><li>样式的类名指定不要用class，用className</li><li>内联样式，要用style=的形式去写</li><li>只有一个根标签</li><li>标签必须闭合</li><li>标签首字母</li></ol><p>（1）若小写字母开头，则将该标签转为html中同名元素，若无则报错</p><p>（2）若大写字母开头，React会去渲染对应的组件，若组件没有定义则报错</p><h2 id="1-4模块与组件"><a href="#1-4模块与组件" class="headerlink" title="1.4模块与组件"></a>1.4模块与组件</h2><p>模块：向外提供特定功能的js程序，一般就是一个js文件</p><p>组件：用来实现局部功能效果的代码和资源的集合（html/css/js/image等等）</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络原理（八）</title>
    <link href="/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第八章-网络安全基础"><a href="#第八章-网络安全基础" class="headerlink" title="第八章 网络安全基础"></a>第八章 网络安全基础</h1><h2 id="一、网络安全概述"><a href="#一、网络安全概述" class="headerlink" title="一、网络安全概述"></a>一、网络安全概述</h2><p>1.基本概念 </p><p>网络安全所需要的基本属性：机密性、消息完整性、可访问与可用性、身份认证</p><p>网络安全是指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断</p><p>2.网络安全威胁 </p><p>网络主要面临安全威胁有：首先，从报文传输方面，主要包括窃听、插入、假冒、劫持等安全威胁。比较常见的网络攻击还包括拒绝服务 DoS 以及分布式拒绝服务 DDoS 等。其次还包括映射、分组“嗅探”和 IP 欺骗等</p><h2 id="二、数据加密"><a href="#二、数据加密" class="headerlink" title="二、数据加密"></a>二、数据加密</h2><p>1.传统加密方式：</p><ul><li>替代密码</li><li>换位密码</li></ul><p>2.现代密码分类：</p><p>对称秘钥加密：加密秘钥和解密秘钥相同（密钥保密，私钥）</p><p>非对称秘钥加密：加密秘钥和解密秘钥不相同</p><h2 id="三、消息完整性与数字签名"><a href="#三、消息完整性与数字签名" class="headerlink" title="三、消息完整性与数字签名"></a>三、消息完整性与数字签名</h2><p>1.报文认证 </p><p>消息完整性检测的一个重要目的就是要完成报文认证的任务。对报文应用散列函数，得到一个固定长度的散列码，称为报文摘要。报文认证的目的有两个：一个是消息源的认证，即验证消息的来源是真实的；另一个是消息的认证，即验证消息在传送过程中未被篡改。 </p><p>2.数字签名 </p><p>报文完整性认证的过程中，数字签名是有效地技术手段。数字签名就是用私钥进行加密，而认证就是利用公开密钥进行正确地解密，所以报文加密技术是数字签名的基础。数字签名包括简单数字签名和签名报文摘要</p><h2 id="四、身份认证"><a href="#四、身份认证" class="headerlink" title="四、身份认证"></a>四、身份认证</h2><p>身份认证又称身份鉴别，是一个实体经过计算机网络向另一个实体证明其身份的过程</p><h2 id="五、秘钥分发中心与证书认证机构"><a href="#五、秘钥分发中心与证书认证机构" class="headerlink" title="五、秘钥分发中心与证书认证机构"></a>五、秘钥分发中心与证书认证机构</h2><p>1.秘钥分发中心 </p><p>对称密钥分发的典型解决方案是，通信各方建立一个大家都信赖的密钥分发中心 (Key </p><p>Distribution Center, KDC),并且每一方和 KDC 之间都保持一个长期的共享密钥</p><p>2.证书认证机构 </p><p>将公钥与特定实体绑定，通常是由认证中心（Certification Authority, CA）完成的。CA 具 </p><p>有以下作用。 </p><p>1）CA 可以证实一个实体的真实身份</p><p>2）一旦 CA 验证了某个实体的身份，CA 会生成一个把其身份和实体的公钥绑定起来的证书,其中包含该实体的公钥及其全局唯一的身份识别信息等，并由 CA 对证书进行数字签名</p><h2 id="六、防火墙与入侵检测系统"><a href="#六、防火墙与入侵检测系统" class="headerlink" title="六、防火墙与入侵检测系统"></a>六、防火墙与入侵检测系统</h2><p>防火墙是能够隔离组织内部网络与公共互联网，允许某些分组通过，而阻止其他分组进入或离开内部网络的软件、硬件或者软件硬件结合的一种设施</p><h2 id="七、网络安全协议"><a href="#七、网络安全协议" class="headerlink" title="七、网络安全协议"></a>七、网络安全协议</h2><p>1.电子邮件对网络安全的需求：机密性、完整性、身份认证性、抗抵赖性</p><p>安全电子邮件标准是 PGP 标准</p><p>2.安全套接字层 SSL 是由 NetScape 最先实现，并广泛部署的安全协议，几乎所有的浏览器和 Web 服务器都支持（介于应用层与传输层之间）</p><p>简化的 SSL 主要包含 4 个部分：</p><p>1）发送方和接收方利用各自证书、私钥认证、鉴别彼此，交换共享密钥</p><p>2）密钥派生或密钥导出</p><p>3）数据传输</p><p>4）连接关闭</p><ol start="3"><li>虚拟专用网（VPN）是建立在公共网络上的安全通道</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络原理（七）</title>
    <link href="/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-无线与移动网络"><a href="#第七章-无线与移动网络" class="headerlink" title="第七章 无线与移动网络"></a>第七章 无线与移动网络</h1><h2 id="一、无线网络"><a href="#一、无线网络" class="headerlink" title="一、无线网络"></a>一、无线网络</h2><p>1.无线网络基本结构 </p><p>无线网络主要包括：无线主机、无线链路、基站、网络基础设施</p><p>Ad Hoc 自组织网络无线主机不通过基站（即没有基站），直接与另一个无线主机直接通信。自组织网络没有基站、无线主机，也不与网络基础设施相连，因此，主机本身必须提供诸如路由选择、地址分配等服务。故 Ad Hoc 网络中的每个节点都兼有路由器和主机两种功能</p><p>2.无线链路与无线网络特性</p><p>无线链路有别于有线链路的主要表现在以下方面：信号强度的衰减、干扰、多径传播、隐藏终端（检测不到碰撞）</p><h2 id="二、移动网络"><a href="#二、移动网络" class="headerlink" title="二、移动网络"></a>二、移动网络</h2><p>无线网络不一定是移动网络、但移动网络一定是无线网络。移动网络中的移动结点是随时间改变其与网络连接位置的结点，并且移动采用无线通信技术 </p><p>1.寻址 </p><ul><li>外部网络可以通过向所有其他网络发通告，告诉它们该移动结点正在它的网络中</li><li>将移动网络功能从网络核心搬到网络边缘，由该移动结点的<strong>归属网络</strong>来实现</li></ul><p>2.移动结点的路由选择 </p><ul><li>间接路由选择：由归属代理转发数据给外部代理</li><li>直接路由选择：由通信代理通过归属代理获得转交地址，直接发送到外部代理</li></ul><h2 id="三、无线局域网IEEE-802-11"><a href="#三、无线局域网IEEE-802-11" class="headerlink" title="三、无线局域网IEEE 802.11"></a>三、无线局域网IEEE 802.11</h2><p>1.IEEE802.11 体系结构 </p><p>基站（AP）和基本服务集（BSS）</p><p>2.IEEE 802.11 的 MAC协议</p><p>IEEE 802.11 的 MAC 协议采用 CSMA/CA 协议（带碰撞避免的CSMA）</p><p>3.IEEE 802.11 帧</p><p>IEEE 802.11 帧共有 3 种类型：控制帧、数据帧和管理帧。IEEE 802.11 数据帧结构：MAC首部（30 字节）、帧主体、尾部（FCS）</p><h2 id="四、蜂窝网络"><a href="#四、蜂窝网络" class="headerlink" title="四、蜂窝网络"></a>四、蜂窝网络</h2><p>蜂窝网络体系结构</p><p>基站系统BSS：基站控制器、收发基站</p><p>移动交换中心MSC</p><p>网关MSC</p><h2 id="五、移动IP网络"><a href="#五、移动IP网络" class="headerlink" title="五、移动IP网络"></a>五、移动IP网络</h2><p>移动 IP 标准由 3 部分组成：代理发现、向归属代理注册以及数据报的间接路由选择</p><h2 id="六、其他典型无线网络简介"><a href="#六、其他典型无线网络简介" class="headerlink" title="六、其他典型无线网络简介"></a>六、其他典型无线网络简介</h2><p>WiMax 全球微波互联接入(WiMax)称为 IEEE 802.16 标准，目的是在更大范围内为用户提供可以媲美有线网络的无线通信解决方案</p><p>蓝牙 IEEE 802.15.1 网络以小范围、低功率和低成本运行</p><p>ZigBee IEEE 第二个个人区域网络标准是 IEEE 802.15.4，称为 ZigBee。ZigBee 主要以低功率、低数据速率、低工作周期应用为目标</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网路原理（六）</title>
    <link href="/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E5%8E%9F%E7%90%86%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-物理层"><a href="#第六章-物理层" class="headerlink" title="第六章 物理层"></a>第六章 物理层</h1><h2 id="一、数据通信基础"><a href="#一、数据通信基础" class="headerlink" title="一、数据通信基础"></a>一、数据通信基础</h2><p>1.数据通信基本概念</p><p>消息与信息：信息是消息中包含的有意义的内容，消息是信息的载体</p><p>通信：本质就是在一点精确或近似地再生另一点的信息</p><p>通信系统：能够实现通信功能的各种技术、设备和方法的总体</p><p>信号：在传输通道中传播<strong>信息的载体</strong></p><p>数据：对客观事物的性质状态以及相互关系等进行记载的<strong>符号</strong>及其组合</p><p>信道：以传输介质为基础的信号通道</p><p>2.数据通信系统模型</p><p>数据通信系统的构成：信源、发送设备、信道、信宿、噪声</p><p>模拟通信和数字通信：</p><p>模拟信号的因变量是<strong>连续</strong>的，数字信号的因变量是<strong>离散</strong>的</p><p><img src="/pic/jiwang/40.png" alt="数据通信方式"></p><h2 id="二、物理介质"><a href="#二、物理介质" class="headerlink" title="二、物理介质"></a>二、物理介质</h2><p>1.引导型传输介质 </p><ul><li>架空明线</li><li>双绞线</li><li>同轴电缆</li><li>光纤 </li></ul><p>2.非引导型传输介质 </p><ul><li>地波传输</li><li>天波传输</li><li>视线传输</li></ul><h2 id="三、信道与信道容量"><a href="#三、信道与信道容量" class="headerlink" title="三、信道与信道容量"></a>三、信道与信道容量</h2><p>1.信道分类与模型</p><p><img src="/pic/jiwang/41.png"></p><p>2.信道传输特性</p><p><img src="/pic/jiwang/42.png"></p><p>3.信道容量</p><p>（1）奈奎斯特公式，给出了<strong>理想无噪声信道</strong>的信道容量：C = 2B1og2M 式中，C 为信道容量，单位为 bit/s 或 bps；B 为信道带宽，单位为 Hz；M 为进制数，即信号状态数</p><p>（2）香农公式给出连续信道的信道容量为：C=Blog2（1+S/N）</p><p>（3）离散信道容量：每个符号能传输的最大平均信息量和单位时间内能够传输的最大平均信息量</p><h2 id="四、基带传输"><a href="#四、基带传输" class="headerlink" title="四、基带传输"></a>四、基带传输</h2><p>1.基带传输基本概念</p><p>基带传输：直接在信道中传送基带信号</p><p>2.数字基带传输编码</p><p><img src="/pic/jiwang/43.png"></p><p><img src="/pic/jiwang/44.png"></p><h2 id="五、频带传输"><a href="#五、频带传输" class="headerlink" title="五、频带传输"></a>五、频带传输</h2><p><img src="/pic/jiwang/45.png" alt="三种调制方式"></p><h2 id="六、物理层接口规程"><a href="#六、物理层接口规程" class="headerlink" title="六、物理层接口规程"></a>六、物理层接口规程</h2><p>物理层接口特性： </p><p>（1）机械特性：也叫物理特性，指明通信实体间硬件连接接口的机械特点</p><p>（2）电气特性：规定了在物理连接上，导线的电气连接及有关电路的特性</p><p>（3）功能特性：指明物理接口各条信号线的用途，包括接口信号线功能的规定方法以及接口信号线的功能分类</p><p>（4）规程特性：即通信协议，指明利用接口传输比特流的全过程，以及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式，即在物理连接建立、维持和交换信息时， DTE（数据终端设备）、DCE（数据电路端接设备）双方在各自电路上的动作序列等</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络原理（五）</title>
    <link href="/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2021/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-数据链路层与局域网"><a href="#第五章-数据链路层与局域网" class="headerlink" title="第五章 数据链路层与局域网"></a>第五章 数据链路层与局域网</h1><h2 id="一、数据链路层服务"><a href="#一、数据链路层服务" class="headerlink" title="一、数据链路层服务"></a>一、数据链路层服务</h2><p>链路：通信链路连接的相邻结点的通信信道</p><p>数据链路层传输的数据单元称为<strong>帧</strong>。数据链路层通常提供以下几点服务：</p><p>1）组帧（加上帧头，帧尾）</p><p>2）链路接入：点对点链路、广播链路</p><p>3）可靠交付</p><p>4）差错控制</p><h2 id="二、差错控制"><a href="#二、差错控制" class="headerlink" title="二、差错控制"></a>二、差错控制</h2><p>1.差错控制的四种基本方式</p><ul><li>检错重发</li><li>前向纠错（接收端进行差错纠正）</li><li>反馈校验（接收端将收到的数据原封不动发回发送端）</li><li>检错丢弃</li></ul><p>2.差错编码的基本原理</p><p><strong>香农信道编码定理</strong>：理论上可以通过编码使得数据传输过程不发生错误，或者将错误概率控制在很小的数值之下</p><p>3.差错编码的检错与纠错能力</p><p><strong>汉明距离</strong>：两个等长码字之间，对应位不同的位数</p><p>编码集的汉明距离：该编码集中任意两个码字之间汉明距离的最小值</p><p>差错编码的检错或纠错能力跟该差错编码的编码集的汉明距离有关</p><p>1）对于检错编码，如果编码集的汉明距离 ds=r+1,则该差错编码可以检测 r 位的差错</p><p>2）对于纠错编码，如果编码集的汉明距离 ds=2r+1,,则该差错编码可以纠正 r 位的差错</p><p>4.典型的差错编码</p><p><img src="/pic/jiwang/35.png"></p><p><img src="/pic/jiwang/39.png" alt="CRC解题思路"></p><h2 id="三、多路访问控制协议"><a href="#三、多路访问控制协议" class="headerlink" title="三、多路访问控制协议"></a>三、多路访问控制协议</h2><p>多路访问控制MAC：广播信道上用于协调各个结点的数据发送</p><p><img src="/pic/jiwang/36.png"></p><p><img src="/pic/jiwang/37.png"></p><h2 id="四、局域网"><a href="#四、局域网" class="headerlink" title="四、局域网"></a>四、局域网</h2><p>1.数据链路层寻址与 ARP</p><p>MAC地址：每个接口对应一个MAC地址，且全球唯一（应用层域名、传输层端口、网络层IP地址、数据链路层MAC地址，都唯一且互不冒犯），长度48位</p><p>地址解析协议（ARP）：根据本网内目的主机或默认网关的 IP 地址获取其 MAC 地址（查询/响应的<strong>广播</strong>方式）</p><p>2.以太网</p><p>以太网采用 CSMA/CD 控制访问方法</p><p>以太网技术：（1）10Base-T 以太网–10兆 基带传输 双绞线/距离（2）快速以太网（3）千兆位以太网（4）万兆位 </p><p>以太网</p><p>3.交换机</p><p>采用转发与过滤的方式，避免广播形式出现的碰撞，交换机通过<strong>自学习</strong>构建交换表</p><p>交换机就是<strong>多端口网桥</strong>，是目前应用最广泛的数据链路层设备</p><p>交换机的优点是：消除冲突、支持异质链路、易于进行网络管理</p><p>4.虚拟局域网（VLAN）</p><p>虚拟局域网是一种基于交换机（必须支持 VLAN 功能）的逻辑分割广播域的局域网应用形式（能够抑制广播风暴）</p><p><img src="/pic/jiwang/38.png"></p><p>划分虚拟局域网的方法主要有三种：基于交换机端口划分、基于 MAC 地址划分、基于上层 协议类型或地址划分</p><h2 id="五、点对点链路协议"><a href="#五、点对点链路协议" class="headerlink" title="五、点对点链路协议"></a>五、点对点链路协议</h2><p>1.点对点协议（PPP）</p><p>PPP 能够处理差错检测、支持多种上层协议（即支持复用）、允许在连接时刻协商 IP 地址、允许身份认证等</p><p>典型应用：拨号上网</p><p>功能：成帧、链路控制协议LCP、网络控制协议NCP</p><p>2.高级数据链路控制协议（HDLC）</p><p>可应用与点对点链路和点对多点链路</p><p>原理：HDLC 协议是面向位的协议，为确保数据的透明传输，HDLC 使用<strong>位填充</strong>。首先，发送端扫描整个数据字段，只要发现 5 个连续的 1，就立即插入一个 0。接收端接收一个帧后，先找到标志字段确定帧的边界，接着利用硬件扫描整个比特流，当发现 5 个连续的 1，就删除其后的 0，以还原原来的信息</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络原理（四）</title>
    <link href="/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h1><h2 id="一、网络层服务"><a href="#一、网络层服务" class="headerlink" title="一、网络层服务"></a>一、网络层服务</h2><p>网络层的主要作用是将（承载传输层报文段的）网络层数据报从<strong>源主机</strong>送达<strong>目的主机</strong></p><p>主要功能包括：</p><ul><li>转发：分组从输入接口转移到输出接口</li><li>路由选择：决定分组经过的路由或路径</li></ul><p><img src="/pic/jiwang/29.png"></p><h2 id="二、数据报网络与虚电路网络"><a href="#二、数据报网络与虚电路网络" class="headerlink" title="二、数据报网络与虚电路网络"></a>二、数据报网络与虚电路网络</h2><p>1.数据报网络 </p><p>按照目的主机地址进行路由选择的网络称为数据报网络</p><p>2.虚电路网络</p><p>虚电路网络在网络层提供面向连接的分组交换服务</p><h2 id="三、网络互连与网络互连设备"><a href="#三、网络互连与网络互连设备" class="headerlink" title="三、网络互连与网络互连设备"></a>三、网络互连与网络互连设备</h2><p>1.异构网络主要是指两个网络的<strong>通信技术</strong>和<strong>运行协议</strong>的不同</p><p>实现异构网络互连的基本策略：</p><ul><li>协议转换</li><li>构建虚拟互联网络</li></ul><p>2.路由器</p><p>在网络层实现网络互连的设备是<strong>路由器</strong>。集线器和中继器都是物理层设备。交换机和网桥是数据链路层设备，<strong>交换机</strong>就是多端口的网桥，是目前应用最广泛的数据链路层设备</p><p><img src="/pic/jiwang/30.png"></p><h2 id="四、网络层拥塞控制"><a href="#四、网络层拥塞控制" class="headerlink" title="四、网络层拥塞控制"></a>四、网络层拥塞控制</h2><p><img src="/pic/jiwang/31.png"></p><h2 id="五、Internet网络层"><a href="#五、Internet网络层" class="headerlink" title="五、Internet网络层"></a>五、Internet网络层</h2><p>1.IPv4协议</p><p><img src="/pic/jiwang/32.png" alt="IP数据报格式"></p><p>2.IPv4编址</p><p>IP 地址划分为两部分：前缀（网络号）和后缀（主机号）。定长前缀为分类地址， 无类地址中网络地址前缀长度可变</p><p><img src="/pic/jiwang/33.png"></p><p><strong>子网划分</strong>：子网化就是指将一个较大的子网划分为多个较小子网的过程。超网化是指将具有较长前缀的相对较小的子网合并为一个具有稍短前缀的相对较大的子网。 超网化是子网化的逆过程。子网掩码用来定义一个子网的网络前缀长度，是一个 32 位数，取值规则是：对应网络前缀，全部为 1，其余全部为 0</p><p><strong>路由聚合</strong>：路由聚合是为了提高路由效率，减少路由表项数，尽可能将能够聚合在一起的子网聚合成一个大的子网。“下一跳地址”和“接口”相同，才能聚合</p><p>3.动态主机配置协议 DHCP </p><p>工作过程：</p><ul><li>DHCP 服务器发现</li><li>DHCP 服务器提供</li><li>DHCP 请求 </li><li>DHCP  确认</li></ul><p>4.网络地址转换</p><p>NAT 工作原理：对于从内网出去，进入公共互联网的 IP 数据报，将其源 IP 地址替换为 NAT 服务器拥有的合法的公共 IP 地址， 同时替换源端口号，并将替换关系记录到 NAT 转换表中；对于从公共互联网返回的 IP 数据报，依据其目的 IP 地址与目的端口号检索 NAT 转换 表，并利用检索到的内部私有 IP 地址与对应的端口号替换目的 IP 地址和目的端口号，然后将 IP 数据报转发到内部网络</p><p>5.ICMP（互联网控制报文协议）</p><p>ICMP 包括 3 个字段：类型、代码和校验和</p><p>ICMP 差错报告报文有 5 种： 终点不可达、 源点抑制、 时间超时、 参数问题、 路由重定向。ICMP 询问报文： 回声（echo） 请求/应答（Ping命令）、 时间戳请求/应答</p><p>6.IPv6</p><ul><li>解决IPv4地址耗尽的问题</li><li>IPv6报文首部长度固定40字节</li><li>IPv6地址长度128位</li><li>IPv4到IPv6的迁移<ul><li>双协议栈</li><li>隧道</li></ul></li></ul><h2 id="六、路由算法与路由协议"><a href="#六、路由算法与路由协议" class="headerlink" title="六、路由算法与路由协议"></a>六、路由算法与路由协议</h2><p><img src="/pic/jiwang/34.png"></p><p>层次化路由选择：实现大规模网络路由选择最有效的、最可行的解决方案。每个自治系统都存在网关路由器。层次化路由选择将大规模互联网的路由划分为两层：<strong>自治系统内路由选择</strong>和<strong>自治系统间路由选择</strong></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络原理（三）</title>
    <link href="/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-传输层"><a href="#第三章-传输层" class="headerlink" title="第三章 传输层"></a>第三章 传输层</h1><h2 id="一、传输层的基本服务"><a href="#一、传输层的基本服务" class="headerlink" title="一、传输层的基本服务"></a>一、传输层的基本服务</h2><p>1.传输层功能</p><p>传输层的<strong>核心任务</strong>是：是为应用进程之间提供端到端的逻辑通信服务</p><p>功能：传输层寻址；对应用层报文进行分段和重组；对报文进行差错检测；实现进程间端到端可靠数据传输控制；面向应用层实现复用与分解；实现端到端的流量控制；拥塞控制等</p><p>2.传输层寻址与端口</p><p>用统一的寻址方法对应用进程进行标识–<strong>端口号</strong></p><p>在全网范围内利用“<strong>IP地址+端口号</strong>”唯一标识一个通信端点（应用程序）</p><p>传输层端口号为16位整数</p><p><img src="/pic/jiwang/22.png"></p><p>3.无连接服务与面向连接服务</p><p>无连接服务是指数据传输之前无需与对端进行任何信息交换（即“握手”），直接构造传输层报文段并向接收端发送–<strong>UDP</strong></p><p>面向连接服务是指在数据传输之前，需要双方交换一些控制信息，<strong>建立逻辑连接</strong>，然后再传输数据，数据传输结束后还需要再拆除连接–<strong>TCP</strong></p><h2 id="二、传输层的复用与分解"><a href="#二、传输层的复用与分解" class="headerlink" title="二、传输层的复用与分解"></a>二、传输层的复用与分解</h2><p><img src="/pic/jiwang/23.png"></p><h2 id="三、停-等协议与滑动窗口协议"><a href="#三、停-等协议与滑动窗口协议" class="headerlink" title="三、停-等协议与滑动窗口协议"></a>三、停-等协议与滑动窗口协议</h2><p>1.可靠数据传输基本原理</p><p>不可靠传输信道在数据传输中可能发生：（1）比特差错（2）乱序（3）数据丢失</p><p>实现可靠数据传输的措施主要包括以下几种：</p><ul><li>差错检测：利用差错编码实现数据包传输过程中的比特差错检测（甚至纠正）</li><li>确认：接收方向发送方反馈接收状态</li><li>重传：发送方重新发送接收方没有正确接收的数据</li><li>序号：确保数据按序提交</li><li>计时器：解决数据丢失问题</li></ul><p>2.停-等协议</p><p>停-等协议的基本工作过程是：</p><p> 1、发送方发送经过差错编码和编号的报文段，等待接收方的确认（<strong>发送并等待确认</strong>）</p><p>2、接收方如果正确接收报文段，即差错检测无误且序号正确，则接收报文段，并 </p><p>向发送方发送 ACK，否则丢弃报文段，并向发送方发送 NAK（<strong>接收并确认/否认</strong>）</p><p>3、发送方如果收到 ACK，则继续发送后续报文段，否则重发刚刚发送的报文段（<strong>继续发送/重发</strong>）</p><p>3.滑动窗口协议</p><p>停止-等待机制<strong>降低了信道利用率</strong>，解决方法：流水线协议或管道协议–允许发送方在没有收到确认前连续发送多个分组，典型的流水线协议：<strong>滑动窗口协议</strong></p><p>流水线协议的改进：</p><ul><li>增加分组序号范围</li><li>发送方和（或）接收方必须缓存多个分组</li></ul><p>两种最具代表性的滑动窗口协议是：<strong>GBN 协议</strong>（发送窗口≥1，接收窗口=1）和 <strong>SR 协议</strong> （发送窗口和接收窗口都大于 1）</p><h2 id="四、用户数据报协议（UDP）"><a href="#四、用户数据报协议（UDP）" class="headerlink" title="四、用户数据报协议（UDP）"></a>四、用户数据报协议（UDP）</h2><p>用户数据报协议 UDP 是 Internet 传输层协议，提供无连接、不可靠、数据报尽力传输服务。UDP 与 TCP 相比，优点有：（1）应用进程更容易控制发送什么数据以及何时发送（2）无需建立连接（3）无连接状态（4）首部开销小</p><p><img src="/pic/jiwang/24.png" alt="UDP数据报结构"></p><h2 id="五、传输控制协议（TCP）"><a href="#五、传输控制协议（TCP）" class="headerlink" title="五、传输控制协议（TCP）"></a>五、传输控制协议（TCP）</h2><p>1.TCP报文段结构</p><p><img src="/pic/jiwang/25.png"></p><p>2.TCP连接管理</p><p>连接建立–三次握手</p><ul><li>SYN连接请求（同步）</li><li>SYNACK确认</li><li>ACK确认</li></ul><p><img src="/pic/jiwang/27.png" alt="建立连接--三次握手"></p><p><img src="/pic/jiwang/28.png" alt="断开连接--四次挥手"></p><p><img src="/pic/jiwang/26.png" alt="总结"></p><p>3.TCP可靠数据传输</p><p>TCP 的可靠数据传输实现机制包括差错编码、确认、序号、重传、计时器等</p><p>4.TCP流量控制</p><p>流量控制（flow control）的目的是协调协议发送方与接收方的数据发送与接收速度，避免因发送方发送数据太快，超出接收方的数据接收和处理能力，导致接收方被数据“淹没”</p><p>5.TCP拥塞控制</p><p>拥塞控制（congestion control）就是通过合理调度、规范、调整向网络中发送数据的主机数量、发送速率或数据量，以避免拥塞或尽快消除己发生的拥塞</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基本语法</title>
    <link href="/2021/10/24/Git%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/10/24/Git%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/pic/Git/1.png" alt="脑图"></p><h1 id="一、版本控制"><a href="#一、版本控制" class="headerlink" title="一、版本控制"></a>一、版本控制</h1><h3 id="1-什么是版本控制？"><a href="#1-什么是版本控制？" class="headerlink" title="1.什么是版本控制？"></a>1.什么是版本控制？</h3><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术，简单说就是用于管理多人协同开发项目的技术</p><h3 id="2-常见的版本控制工具"><a href="#2-常见的版本控制工具" class="headerlink" title="2.常见的版本控制工具"></a>2.常见的版本控制工具</h3><p>Git、SVM、CVS、VSS、TFS…</p><h3 id="3-版本控制分类"><a href="#3-版本控制分类" class="headerlink" title="3.版本控制分类"></a>3.版本控制分类</h3><ul><li>本地版本控制</li></ul><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS</p><ul><li>集中版本控制（SVM）</li></ul><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作，如SVN、CVS、VSS</p><ul><li>分布式版本控制（Git）</li></ul><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里</p><h1 id="二、常用的Linux命令"><a href="#二、常用的Linux命令" class="headerlink" title="二、常用的Linux命令"></a>二、常用的Linux命令</h1><ul><li>cd：改变目录<ul><li>cd..：回退到上一个目录，直接cd进入默认目录</li></ul></li><li>pwd：显示当前所在的目录路径</li><li>ls（ll）：都是列出当前目录中的所有文件，只不过ll（两个ll）列出的内容更详细</li><li>touch : 新建一个文件如 touch index.js，就会在当前目录下新建一个index.js文件</li><li>mkdir:  新建一个目录，就是新建一个文件夹</li><li>rm:  删除一个文件，rm index.js 就会把index.js文件删除<ul><li>rm -r :  删除一个文件夹，rm -r src 删除src目录</li><li>rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！（f迭代，/根目录）</li></ul></li><li>mv：移动文件, mv index.html src，index.html 是我们要移动的文件,，src 是目标文件夹， 这样写必须保证文件和目标文件夹在同一目录下</li><li>reset：重新初始化终端/清屏</li><li>clear 清屏</li><li>history 查看命令历史</li><li>help 帮助</li><li>exit 退出</li><li>“#”表示注释</li></ul><h1 id="三、Git基本概念"><a href="#三、Git基本概念" class="headerlink" title="三、Git基本概念"></a>三、Git基本概念</h1><p><img src="/pic/Git/2.jpg"></p><ul><li><p>工作区</p><ul><li>本地项目存放文件的位置，即workspace</li></ul></li><li><p>暂存区(Index/Stage)</p><ul><li>暂时存放文件的地方，通过<strong>add</strong>命令将工作区的文件加到缓冲区</li></ul></li><li><p>本地仓库(Repository)</p><ul><li>通常情况下，我们使用<strong>commit</strong>命令可以将暂存区的文件添加到本地仓库</li><li>通常而言，HEAD指针指向的是master分支</li></ul></li><li><p>远程仓库(Remote)</p><ul><li>GitHub托管项目时，它就是一个远程仓库</li><li>通常我们使用clone命令将远程仓库代码拷贝下来，本地代码更新后，通过<strong>push</strong>推送到远程仓库</li></ul></li></ul><p><img src="/pic/Git/3.jpg" alt="基本工作流程"></p><h1 id="四、Git进阶"><a href="#四、Git进阶" class="headerlink" title="四、Git进阶"></a>四、Git进阶</h1><h3 id="1-Git使用前配置"><a href="#1-Git使用前配置" class="headerlink" title="1.Git使用前配置"></a>1.Git使用前配置</h3><p>在使用git前，需要告诉git你是谁，在向git仓库中提交时需要用到。</p><ol><li>配置提交人姓名:<code>git config --global user.name 提交人姓名</code></li><li>配置提交人邮箱:<code>git config --global user.email 提交人邮箱</code></li><li>查看git配置信息:<code>git config --list</code></li></ol><blockquote><p><strong>注意</strong></p></blockquote><ul><li>如果要对配置信息进行修改，重复上述命令即可</li><li>配置只需要执行一次。</li></ul><h3 id="2-提交步骤"><a href="#2-提交步骤" class="headerlink" title="2.提交步骤"></a>2.提交步骤</h3><ul><li><p><code>git init</code>初始化git仓库</p></li><li><p><code>git status</code>查看文件状态</p></li><li><p><code>git add 文件列表</code>追踪文件</p></li><li><p><code>git commit -m 提交信息</code>向本地仓库中提交代码</p></li><li><p><code>git log</code>查看提交记录</p></li><li><p><code>git push https://github.com/ovfan/git-demo.git master</code>本地仓库推送到GitHub远程仓库</p></li><li><p><code>git remote add origin https://github.com/ovfan/git-demo.git</code> 为远端仓库地址添加别名</p><ul><li>添加完别名后，下次推送使用<code>git push origin master</code></li></ul></li><li><p><code>git push -u 远程仓库地址别名 分支名称</code> -u 记住推送地址及分支，下次推送只需要输入<code>git push</code>即可</p></li></ul><h3 id="3-分支命令"><a href="#3-分支命令" class="headerlink" title="3.分支命令"></a>3.分支命令</h3><ul><li><code>git branch</code> 查看本地分支</li><li><code>git branch -r</code>查看远程分支</li><li><code>git branch 分支名称</code>创建分支<ul><li><code>git checkout -b 分支名称</code>创建并切换到新建分支</li></ul></li><li><code>git checkout 分支名称</code>切换分支</li><li><code>git merge 来源分支</code>合并分支</li><li><code>git branch -d 分支名称</code>删除分支<ul><li>分支被合并后才允许删除</li><li><code>git branch -D</code>强制删除</li></ul></li><li><code>git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt;</code>重命名分支</li><li><code>git add .</code>全部上传到缓存区<ul><li><code>git add 指定文件</code>指定文件上传到缓存区</li></ul></li></ul><h1 id="五、小灶"><a href="#五、小灶" class="headerlink" title="五、小灶"></a>五、小灶</h1><h3 id="1-拉取操作"><a href="#1-拉取操作" class="headerlink" title="1.拉取操作"></a>1.拉取操作</h3><ul><li>克隆远端数据仓库到本地：<code>git clone 仓库地址</code></li><li>拉取远程仓库中最新的版本：<code>git pull 远程仓库地址 分支名称</code></li></ul><h3 id="2-ssh免登录"><a href="#2-ssh免登录" class="headerlink" title="2.ssh免登录"></a>2.ssh免登录</h3><ul><li>生成密钥：<code>ssh-keygen</code></li><li>密钥存储目录:<code>C:\Users\shinelon\.ssh</code></li><li>公钥名称：<code>id_rsa.pub</code></li><li>私钥名称：<code>id_rsa</code></li></ul><h3 id="3-Git忽略清单"><a href="#3-Git忽略清单" class="headerlink" title="3.Git忽略清单"></a>3.Git忽略清单</h3><p>将不需要被git管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件，git忽略清单文件名称：<strong>「.gitignore」</strong></p><p>参考</p><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/koameBEQILNz1ViT_oB_cQ">前端fan</a></li><li><a href="https://mp.weixin.qq.com/s/Bf7uVhGiu47uOELjmC5uXQ">狂神聊Git</a></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络原理（二）</title>
    <link href="/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-网络应用"><a href="#第二章-网络应用" class="headerlink" title="第二章 网络应用"></a>第二章 网络应用</h1><h2 id="一、计算机网络应用体系结构"><a href="#一、计算机网络应用体系结构" class="headerlink" title="一、计算机网络应用体系结构"></a>一、计算机网络应用体系结构</h2><p><img src="/pic/jiwang/9.png"></p><h2 id="二、网络应用通信基本原理"><a href="#二、网络应用通信基本原理" class="headerlink" title="二、网络应用通信基本原理"></a>二、网络应用通信基本原理</h2><p>网络应用的本质是运行在不同主机上的应用进程之间的通信，无论哪种类型的网络应用，基本通信方式都是C/S通信</p><p><img src="/pic/jiwang/10.png"></p><h2 id="三、域名系统（DNS）"><a href="#三、域名系统（DNS）" class="headerlink" title="三、域名系统（DNS）"></a>三、域名系统（DNS）</h2><p>DNS 是一个重要的基础应用，因为任何一个需要使用域名进行通信的网络应用，在应用通信之前首先需要请求 DNS 应用，将域名映射为 IP 地址。实现将域名映射为 IP 地址的过程，称为<strong>域名解析</strong></p><ol><li> 层次树状结构的命名方法</li></ol><ul><li>国家顶级域名 nTLD</li><li>通用顶级域名 gTLD</li><li>基础结构域名</li></ul><ol start="2"><li> 域名服务器</li></ol><p>为了实现域名解析，需要建立分布式数据库，存储网络中域名与IP地址的映射关系数据</p><ol start="3"><li> 域名服务器分类：</li></ol><ul><li>根域名服务器</li></ul><ul><li>顶级域名服务器</li><li>权威域名服务器</li><li>中间域名服务器</li></ul><ol start="4"><li>  域名解析过程</li></ol><p>递归解析：依次查询</p><p><img src="/pic/jiwang/11.png" alt="递归查询"></p><p>迭代解析：直接响应结果，减轻根域名服务器的压力</p><p><img src="/pic/jiwang/12.png" alt="迭代查询"></p><h2 id="四、万维网应用"><a href="#四、万维网应用" class="headerlink" title="四、万维网应用"></a>四、万维网应用</h2><ol><li> 万维网结构</li></ol><p>Web 应用主要包括 Web 服务器、浏览器与超文本传输协议（HTTP）等部分，浏览器就是 Web 应用的客户端软件，请求首先建立TCP连接</p><p>HTML 基本 Web 页也是通过 URL 地址引用页面中的其他对象，每个 URL 地址主要由<strong>两部分</strong>组成：存放对象的服务器主机域名和对象的路径名</p><ol start="2"><li> HTTP</li></ol><p><img src="/pic/jiwang/13.png"></p><ol start="3"><li> Cookie</li></ol><p>Cookie 是由服务器端生成，是实现服务器对客户状态的跟踪的典型技术</p><p><img src="/pic/jiwang/14.png" alt="Cookie的工作原理"></p><h2 id="五、Internet电子邮件"><a href="#五、Internet电子邮件" class="headerlink" title="五、Internet电子邮件"></a>五、Internet电子邮件</h2><p><img src="/pic/jiwang/15.png"></p><p><img src="/pic/jiwang/16.png"></p><h2 id="六、FTP"><a href="#六、FTP" class="headerlink" title="六、FTP"></a>六、FTP</h2><p>文件传送协议（FTP）是在互联网的两个主机间实现文件互传的应用层协议，C/S模式，采用<strong>控制连接</strong>（21端口）传输控制命令，<strong>数据连接</strong>（20端口）传输文件内容</p><p><img src="/pic/jiwang/17.png" alt="FTP应用结构"></p><h2 id="七、P2P应用"><a href="#七、P2P应用" class="headerlink" title="七、P2P应用"></a>七、P2P应用</h2><p>P2P应用的优势：充分聚集利用了端系统（对等方主机）的计算能力以及网络传输带宽，对服务器的依赖很小</p><p><img src="/pic/jiwang/18.png" alt="文件分发问题"></p><h2 id="八、Socket编程基础"><a href="#八、Socket编程基础" class="headerlink" title="八、Socket编程基础"></a>八、Socket编程基础</h2><p>利用 Socket 编程技术可以开发客户/服务器网络应用程序，网络应用进程通信时需要通过<strong>API接口</strong>请求底层协议的服务，可以创建3种类型的Socket：数据报类型套接字SOCK_DGRAM（面向UDP）、流式套接字 SOCK_STREAM（面向 TCP）和原始套接字 SOCK_RAM</p><p><img src="/pic/jiwang/19.png"></p><p><img src="/pic/jiwang/20.png" alt="基于TCP的Socket编程"></p><p><img src="/pic/jiwang/21.png" alt="基于UDP的Socket编程"></p><h5 id="重难点回顾"><a href="#重难点回顾" class="headerlink" title="重难点回顾"></a>重难点回顾</h5><ul><li>客户/服务器、P2P（Pear to Pear）两种网络应用体系结构及各自的特点</li><li>DNS的概念和工作原理</li><li>万维网应用结构和HTTP协议</li><li>电子邮件系统结构和协议</li></ul>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络原理（一）</title>
    <link href="/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/10/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机网络概述"><a href="#第一章-计算机网络概述" class="headerlink" title="第一章 计算机网络概述"></a>第一章 计算机网络概述</h1><h2 id="一、计算机网络基本概念"><a href="#一、计算机网络基本概念" class="headerlink" title="一、计算机网络基本概念"></a>一、计算机网络基本概念</h2><ol><li>计算机网络是互连的、自治的计算机的集合</li></ol><p>“互连”：指利用通信链路连接相互独立的计算机系统</p><p>“自治”：指互连的计算机系统彼此独立，不存在主从或者控制与被控制的关系</p><ol start="2"><li>协议是网络通信实体之间在数据交换过程中需要遵循的规则或约定，是计算机网络有序运行的重要保证</li></ol><p><strong>协议三要素：语义、语法、时序</strong></p><ul><li>语法，语法定义实体之间交换信息的格式与结构</li><li>语义，语义就是定义实体之间交换的信息中需要发送控制信息</li><li>时序，时序也称为同步，定义实体之间交换信息的顺序以及如何匹配或适应彼此的速度</li></ul><ol start="3"><li>计算机网络的分类</li></ol><p><strong>按覆盖范围分类：</strong></p><p>个域网（PAN）、局域网（LAN）、城域网（MAN）、广域网（WAN）</p><p><strong>按拓扑结构分类：</strong></p><p><img src="/pic/jiwang/1.png" alt="常见的网络拓扑结构"></p><p><strong>按交换方式分类</strong></p><p>电路交换网络、报文交换网络、分组交换网络</p><h2 id="二、计算机网络结构"><a href="#二、计算机网络结构" class="headerlink" title="二、计算机网络结构"></a>二、计算机网络结构</h2><p>大规模现代计算机网络的结构包括<strong>网络边缘、接入网络与网络核心</strong>3部分</p><h2 id="三、数据交换技术"><a href="#三、数据交换技术" class="headerlink" title="三、数据交换技术"></a>三、数据交换技术</h2><p><img src="/pic/jiwang/2.png" alt="交换设备与交换网络的意义"></p><ol><li>电路交换</li></ol><p>电路交换是最早出现的一种交换方式，电话网络则是最早、最大的电路交换网络</p><p>利用电路交换进行通信包括<strong>建立电路、传输数据和拆除电路</strong>3个阶段</p><p><img src="/pic/jiwang/3.png" alt="电路交换"></p><p>优点：<strong>实时性高</strong>，时延较小</p><p>缺点：对于突发性数据传输，<strong>信道利用率低</strong>，且传输速率单一</p><ol start="2"><li>报文交换</li></ol><p><strong>存储-转发</strong>交换方式，适用于电报通信</p><p><img src="/pic/jiwang/4.png" alt="分组交换"></p><p>优点：<strong>不需要建立连接</strong></p><p>缺点：交换结点需要缓冲存储，报文需要<strong>排队</strong>，增加了延时</p><ol start="3"><li>分组交换</li></ol><p>将一个完整报文拆分成若干个<strong>分组</strong>，分组传输过程也通常采用<strong>存储-转发</strong>交换方式</p><p><img src="/pic/jiwang/5.png" alt="分组交换"></p><p>优点：交换设备<strong>存储容量要求低</strong>，交换速度快，可靠传输效率高，更加公平 </p><p>缺点：有效传输效率降低(<strong>分组长度与延迟时间</strong>)</p><h2 id="四、计算机网络性能"><a href="#四、计算机网络性能" class="headerlink" title="四、计算机网络性能"></a>四、计算机网络性能</h2><ol><li> 速率与带宽</li></ol><p><strong>速率</strong>是指网络单位时间内传送的数据量，用以描述网络传输数据的快慢，也称为数据传输速率或数据速率，速率的基本单位是 bit/s（位每秒，简写为bps）带宽</p><p>在计算机网络中，有时也会用“<strong>带宽</strong>”这一术语描述速率</p><p>带宽原本是指信号具有的频带宽度，即信号成分的最高频率与最低频率之差，单位为 Hz（赫兹）</p><ol start="2"><li> 时延</li></ol><p><strong>时延</strong>是指数据从网络中的一个结点（主机或交换设备等）到达另一结点所需要的时间</p><ol start="3"><li> 时延带宽积</li></ol><p>一段物理链路的传播时延与链路带宽的乘积，称为<strong>时延带宽积</strong></p><ol start="4"><li> 丢包率</li></ol><p><strong>丢包率</strong>常被用于评价和衡量网络性能的指标，在很大程度上可以反映网络的拥塞程度</p><p>丢包率=丢失分组总数/发送分组总数</p><ol start="5"><li> 吞吐量</li></ol><p><strong>吞吐量</strong>表示在单位时间内源主机通过网络向目的主机实际送达的数据量，吞吐量经常用于度量网络的实际数据传送（通过）能力。</p><h2 id="五、计算机网络体系结构"><a href="#五、计算机网络体系结构" class="headerlink" title="五、计算机网络体系结构"></a>五、计算机网络体系结构</h2><ol><li> OSI（开放系统互联）参考模型</li></ol><p><img src="/pic/jiwang/6.png" alt="OSI参考模型数据封装与传输过程"></p><ol start="2"><li> TCP/IP参考模型、五层参考模型</li></ol><p><img src="/pic/jiwang/7.png" alt="各模型之间的比较"></p><ol start="3"><li> 各层次的功能</li></ol><p>   <img src="/pic/jiwang/8.png" alt="层次功能"></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="/2021/10/23/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/10/23/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">#  一级标题<br><br>##  二级标题<br><br>###  三级标题<br><br>####  四级标题<br><br>#####  五级标题<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>记得#后面加空格，一级到五级，字体从大到小</li></ul><h1 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h1><ul><li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**这是加粗的文字**</span><br><br><span class="hljs-strong">*这是倾斜的文字*</span><br><br><span class="hljs-strong">***这是斜体加粗的文字**</span>*<br><br>~~这是加删除线的文字~~<br></code></pre></td></tr></table></figure><p><strong>这是加粗的文字</strong></p><p><em>这是倾斜的文字</em></p><p><em><strong>这是斜体加粗的文字</strong></em></p><p><del>这是加删除线的文字</del></p><h1 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h1><p>使用 <code>&gt;</code> 表示，可以有多个 <code>&gt;</code>，表示层级更深</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">这是引用的内容</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;这是引用的内容</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;这是引用的内容</span><br></code></pre></td></tr></table></figure><blockquote><p>这是引用的内容</p></blockquote><h1 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h1><p>三个或者三个以上的 - 或者 * 都可以</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">***</span><br></code></pre></td></tr></table></figure><hr><h1 id="5-超链接"><a href="#5-超链接" class="headerlink" title="5. 超链接"></a>5. 超链接</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[超链接名]</span>(超链接地址 <span class="hljs-string">&quot;超链接title&quot;</span>)<br><br><span class="hljs-selector-tag">title</span>可加可不加<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[百度]</span>(<span class="hljs-attribute">http</span>:<span class="hljs-comment">//baidu.com)</span><br></code></pre></td></tr></table></figure><p><a href="http://baidu.com/">百度</a></p><h1 id="6-图片"><a href="#6-图片" class="headerlink" title="6. 图片"></a>6. 图片</h1><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos">![图片alt](图片地址 &quot;图片<span class="hljs-built_in">title</span>&quot;)<br><br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片<span class="hljs-built_in">title</span>是图片的标题，当鼠标移到图片上时显示的内容<br><span class="hljs-built_in">title</span>可加可不加<br></code></pre></td></tr></table></figure><p>图片和链接的写法类似，图片仅在超链接前多了一个 <code>!</code> </p><p><code>![姜文](/img/favorite.jpeg)</code></p><p><img src="/img/favorite.jpeg" alt="姜文"></p><h1 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h1><ul><li><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5></li></ul><p>无序列表用 - + * 任何一种都可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 列表内容<br><span class="hljs-bullet">+</span> 列表内容<br><span class="hljs-bullet">*</span> 列表内容<br><br>注意：- + <span class="hljs-emphasis">* 跟内容之间都要有一个空格</span><br></code></pre></td></tr></table></figure><ul><li><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5></li></ul><p>数字加点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> 列表内容<br><span class="hljs-number">2.</span> 列表内容<br><span class="hljs-number">3.</span> 列表内容<br><br>注意：序号跟内容之间要有空格<br></code></pre></td></tr></table></figure><ul><li><h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5></li></ul><p>上一级和下一级之间敲三个空格</p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容<ol><li> 三级有序列表内容</li><li> 三级有序列表内容</li></ol></li></ul></li><li><h5 id="高级列表"><a href="#高级列表" class="headerlink" title="高级列表"></a>高级列表</h5><p>有可勾选框的清单</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[x] 1.早睡早起<br><span class="hljs-bullet">- </span>[ ] 2.打代码<br></code></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 1.早睡早起</li><li><input disabled="" type="checkbox"> 2.打代码</li></ul></li></ul><h1 id="8-表格"><a href="#8-表格" class="headerlink" title="8. 表格"></a>8. 表格</h1><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">表头|<span class="hljs-string">表头</span>|<span class="hljs-string">表头</span><br><span class="hljs-string">---</span>|<span class="hljs-string">:--:</span>|<span class="hljs-string">---:</span><br><span class="hljs-string">内容</span>|<span class="hljs-string">内容</span>|<span class="hljs-string">内容</span><br><span class="hljs-string">内容</span>|<span class="hljs-string">内容</span>|<span class="hljs-string">内容</span><br><span class="hljs-string"></span><br><span class="hljs-string">第二行分割表头和内容。</span><br><span class="hljs-string">- 有一个就行，为了对齐，多加了几个</span><br><span class="hljs-string">文字默认居左</span><br><span class="hljs-string">-两边加：表示文字居中</span><br><span class="hljs-string">-右边加：表示文字居右</span><br><span class="hljs-string">注：原生的语法两边都要用 </span>|<span class="hljs-string"> 包起来。此处省略</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">姓名|<span class="hljs-string">技能</span>|<span class="hljs-string">排行</span><br><span class="hljs-string">--</span>|<span class="hljs-string">:--:</span>|<span class="hljs-string">--:</span><br><span class="hljs-string">刘备</span>|<span class="hljs-string">哭</span>|<span class="hljs-string">大哥</span><br><span class="hljs-string">关羽</span>|<span class="hljs-string">打</span>|<span class="hljs-string">二哥</span><br><span class="hljs-string">张飞</span>|<span class="hljs-string">骂</span>|<span class="hljs-string">三弟</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h1 id="9-代码"><a href="#9-代码" class="headerlink" title="9. 代码"></a>9. 代码</h1><ul><li><h5 id="用反引号-来插入行内代码"><a href="#用反引号-来插入行内代码" class="headerlink" title="用反引号 ` 来插入行内代码"></a>用反引号 ` 来插入行内代码</h5><p><code>String name = &quot;Tstto&quot;</code></p></li><li><h5 id="三个连续的反引号-包裹多行代码"><a href="#三个连续的反引号-包裹多行代码" class="headerlink" title="三个连续的反引号 ``` 包裹多行代码"></a>三个连续的反引号 ``` 包裹多行代码</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>  alert(<span class="hljs-string">&quot;这是一句非常牛逼的代码&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2021/10/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/10/23/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><ul><li><p>查看node版本</p><p>node -v</p></li><li><p>查看npm版本</p><p>npm -v</p></li></ul><h2 id="安装淘宝镜像"><a href="#安装淘宝镜像" class="headerlink" title="安装淘宝镜像"></a>安装淘宝镜像</h2><p>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a></p><ul><li><p>查看cnpm版本</p><p>cnpm -v</p></li></ul><h2 id="安装hexo脚手架"><a href="#安装hexo脚手架" class="headerlink" title="安装hexo脚手架"></a>安装hexo脚手架</h2><p>cnpm install -g hexo-cli</p><ul><li><p>查看hexo版本</p><p>hexo -v</p></li></ul><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p><a href="https://npm.taobao.org/mirrors">淘宝Git镜像下载</a></p><ul><li>Windows用户右击打开Git Bash Here进入命令行窗口</li></ul><ul><li><p>创建blog目录(任意盘选择)</p><p>mkdir  blog   //方便后续出现问题及时处理</p></li><li><p>进入blog目录，初始化博客</p><p>cd blog</p><p>hexo init</p></li><li><p>启动本地hexo服务</p><p>hexo s(serve)   //本地默认访问地址<a href="http://localhost:4000/">http://localhost:4000</a></p></li><li><p>创建博客文章</p><p>hexo n(new) xxx(文章title)   //保存目录…\blog\source_posts</p></li><li><p>清理更新</p><p>hexo c(clean)</p></li><li><p>生成</p><p>hexo g(generate) </p></li></ul><h1 id="Github设置"><a href="#Github设置" class="headerlink" title="Github设置"></a>Github设置</h1><p>(内心os：原先想在码云Gitee搭建仓库的，无奈Gitee Pages需实名认证过程繁琐，Github又有墙，博客有时加载速度真的是要了狗命…)</p><ul><li><p>注册创建账号，搭建仓库</p><p>GithubName.github.io(墙裂建议！！！一定要照抄不误的用你的用户名，否则后面可能出现一系列问题)</p></li><li><p>blog目录下安装git部署插件</p><p>cnpm install –save hexo-deployer-git</p></li></ul><h1 id="config-yml配置"><a href="#config-yml配置" class="headerlink" title="_config.yml配置"></a>_config.yml配置</h1><p>灰常重要哦！！！误删误大改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"># Deployment<br>## Docs: https:<span class="hljs-comment">//hexo.io/docs/deployment.html</span><br>deploy:<br>  type: git<br> repo: https:<span class="hljs-comment">//github.com/YourGithubName/YourGithubName.github.io.git</span><br>  branch: master<br>(文件底部可见)<br></code></pre></td></tr></table></figure><ul><li><p>部署到Github仓库</p><p>hexo d(deploy)</p></li><li><p>访问hexo初始化博客</p><p><a href="https://githubname.github.io/">https://GithubName.github.io/</a>   //访问这个地址可以查看博客</p></li></ul><h1 id="下载你喜欢的hexo主题"><a href="#下载你喜欢的hexo主题" class="headerlink" title="下载你喜欢的hexo主题"></a>下载你喜欢的hexo主题</h1><p>git clone <a href="https://github.com/fluid-dev/hexo-theme-fluid.git">https://github.com/fluid-dev/hexo-theme-fluid.git</a>   //我自己用的是Fluid主题，更多热门主题可访问<a href="https://hexo.io/themes/">hexo官网</a>查看对应Readme.md文档</p><ul><li>修改hexo根目录下的 _config.yml 文件 </li></ul><p><code>theme: fluid</code></p><p>hexo c<br>hexo g<br>hexo d   //部署到远程Github仓库<br><a href="https://githubname.github.io/">https://GithubName.github.io/</a>   //查看博客</p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><ul><li>配置指定语言</li></ul><p>_config.yml文件下修改主题指定语言</p><p><code>language: zh-CN</code></p><ul><li>手动创建[分类页]、[标签页]…</li></ul><p>hexo n page 创建页名称</p><ul><li>另外</li></ul><p>完成以上就能够构建一个基本结构，足够美观大气的博客。很多地方还都是官方的默认配置，比如背景图，交互…很难满足每个人的口味，未来很长，除了这一小部分的修修改改，学习的路上还有很多等你攻克的事，加油！(个性化设置基本都在_config.yml中，blog目录和主题Fluid目录下都有 当然如果你有能力自定义的话，也可以打造专属你自己的页面)</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
